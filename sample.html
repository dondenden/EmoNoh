<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>EmoNoh - Mouse Emotion Estimation</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>
  <style>
    body { font-family: sans-serif; background:#f5f7fa; padding:20px; }
    #canvasArea {
      background: white; border:1px solid #ccc;
      width: 500px; height: 300px;
      position: relative; cursor: crosshair;
    }
    #target { 
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      width:50px; height:50px; background:red; border-radius:50%;
    }
    button { margin: 8px 5px; padding: 8px 14px; }
  </style>
</head>
<body>
  <h1>ğŸ–± EmoNoh â€” ãƒã‚¦ã‚¹æ“ä½œã«ã‚ˆã‚‹æ„Ÿæƒ…æ¨å®šãƒ‡ãƒ¢</h1>
  <div>ãƒ•ã‚§ãƒ¼ã‚º: <span id="phaseLabel">æœªé–‹å§‹</span></div>
  <div id="canvasArea">
    <div id="target"></div>
  </div>
  <button id="startBtn">åé›†é–‹å§‹</button>
  <button id="trainBtn">ãƒ¢ãƒ‡ãƒ«å­¦ç¿’</button>
  <button id="predictBtn">æ¨å®šãƒ†ã‚¹ãƒˆ</button>
  <button id="downloadBtn">CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
  <div id="status">çŠ¶æ…‹: å¾…æ©Ÿä¸­</div>

<script>
const phases = [
  { label: "é›†ä¸­", targetSpeed: 1 },
  { label: "å›°æƒ‘", targetSpeed: 2 }, 
  { label: "é€€å±ˆ", targetSpeed: 0 }
];
let currentPhase = 0;
let trial = 0;
const totalTrials = 5;

let moveStartTime = null;
let totalDistance = 0;
let lastX = null, lastY = null;
let clickTimes = [];
let reactionStart = null;
let hasMoved = false;
const data = [];
let model = null;

const canvasArea = document.getElementById('canvasArea');
const target = document.getElementById('target');
const phaseLabel = document.getElementById('phaseLabel');
const status = document.getElementById('status');

// ãƒ©ãƒ³ãƒ€ãƒ ä½ç½®ã¸ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç§»å‹•
function moveTargetRandom(){
  const x = Math.random() * (canvasArea.clientWidth - 50);
  const y = Math.random() * (canvasArea.clientHeight - 50);
  target.style.left = x + "px";
  target.style.top = y + "px";
  reactionStart = Date.now();
  hasMoved = false;
  totalDistance = 0;
  lastX = null; lastY = null;
  clickTimes = [];
}

canvasArea.addEventListener('mousemove', (e)=>{
  const now = Date.now();
  if (!moveStartTime) moveStartTime = now;
  if (lastX !== null) {
    const dx = e.offsetX - lastX;
    const dy = e.offsetY - lastY;
    const dist = Math.sqrt(dx*dx+dy*dy);
    totalDistance += dist;
  } else {
    // æœ€åˆã®ç§»å‹•ã®åå¿œæ™‚é–“
    if (!hasMoved && reactionStart){
      const rt = now - reactionStart;
      reactionTime = rt;
      hasMoved = true;
    }
  }
  lastX = e.offsetX;
  lastY = e.offsetY;
});

canvasArea.addEventListener('click', ()=>{
  clickTimes.push(Date.now());
});

// trial çµ‚äº†æ™‚ã«ç‰¹å¾´é‡æŠ½å‡º
function finishTrial(){
  const elapsed = (Date.now() - reactionStart);
  const avgSpeed = elapsed > 0 ? totalDistance / elapsed : 0;

  let clickInterval = 0;
  if (clickTimes.length > 1) {
    const diffs = [];
    for (let i=1;i<clickTimes.length;i++){
      diffs.push(clickTimes[i]-clickTimes[i-1]);
    }
    clickInterval = diffs.reduce((a,b)=>a+b)/diffs.length;
  }

  data.push({
    phase: currentPhase,
    phaseLabel: phases[currentPhase].label,
    avgSpeed: avgSpeed.toFixed(2),
    reactionTime: hasMoved ? reactionTime : 0,
    clickInterval: clickInterval.toFixed(2)
  });

  trial++;
  if (trial >= totalTrials) {
    trial = 0;
    currentPhase++;
    if (currentPhase >= phases.length){
      status.textContent = "âœ… ãƒ‡ãƒ¼ã‚¿åé›†å®Œäº†";
      return;
    }
  }
  setTimeout(moveTargetRandom, 1000);
}

document.getElementById('startBtn').addEventListener('click', ()=>{
  currentPhase = 0;
  trial = 0;
  phaseLabel.textContent = phases[currentPhase].label;
  moveTargetRandom();
  status.textContent = "åé›†ä¸­...";
  // trialæ¯ã«5ç§’å¾Œã«çµ‚äº†
  const interval = setInterval(()=>{
    finishTrial();
    if (currentPhase >= phases.length) clearInterval(interval);
    else phaseLabel.textContent = phases[currentPhase].label;
  }, 5000);
});

// =====================
// TensorFlow.js
// =====================
function createModel(){
  const m = tf.sequential();
  m.add(tf.layers.dense({inputShape:[3], units:16, activation:'relu'}));
  m.add(tf.layers.dense({units:8, activation:'relu'}));
  m.add(tf.layers.dense({units:3, activation:'softmax'}));
  m.compile({optimizer: tf.train.adam(0.01), loss:'categoricalCrossentropy', metrics:['accuracy']});
  return m;
}

document.getElementById('trainBtn').addEventListener('click', async ()=>{
  if (data.length < 10) return alert("ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã™ãã¾ã™");
  const xs = tf.tensor2d(data.map(d=>[+d.avgSpeed, +d.reactionTime, +d.clickInterval]));
  const ys = tf.oneHot(tf.tensor1d(data.map(d=>d.phase),'int32'), 3);
  model = createModel();
  await model.fit(xs, ys, {epochs: 50, shuffle:true});
  xs.dispose(); ys.dispose();
  status.textContent = "ğŸ§  ãƒ¢ãƒ‡ãƒ«å­¦ç¿’å®Œäº†";
});

document.getElementById('predictBtn').addEventListener('click', ()=>{
  if (!model) return alert("ãƒ¢ãƒ‡ãƒ«ã‚’å…ˆã«å­¦ç¿’ã—ã¦ãã ã•ã„");
  const feat = [0.5, 200, 300]; // ãƒ†ã‚¹ãƒˆå€¤ï¼ˆå®Ÿéš›ã«ã¯åˆ¥ã®å…¥åŠ›ã‚’åé›†ã—ã¦äºˆæ¸¬ï¼‰
  const t = tf.tensor2d([feat]);
  const pred = model.predict(t);
  pred.data().then(arr=>{
    const idx = arr.indexOf(Math.max(...arr));
    status.textContent = `ğŸª æ¨å®šçµæœ: ${phases[idx].label} (ç¢ºä¿¡åº¦ ${(arr[idx]*100).toFixed(1)}%)`;
    t.dispose(); pred.dispose();
  });
});

// CSV ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
document.getElementById('downloadBtn').addEventListener('click', ()=>{
  if (data.length === 0) return alert("ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“");
  const header = Object.keys(data[0]).join(",");
  const rows = data.map(obj => Object.values(obj).join(","));
  const csv = [header, ...rows].join("\n");
  const blob = new Blob([csv], {type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = "mouse_emotion_data.csv";
  a.click();
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>