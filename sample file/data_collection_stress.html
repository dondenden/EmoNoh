<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Mouse Emotion Data Collection Game - Stress Mode</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #gameArea {
      width: 800px; height: 500px; border: 2px solid #333;
      position: relative; margin-bottom: 20px;
      background: #fff3f3;
      overflow: hidden;
    }
    .target, .fake-target {
      width: 40px; height: 40px; border-radius: 50%;
      background: red; position: absolute; cursor: pointer;
    }
    .fake-target { background: #888; }
    #status { font-weight: bold; margin-bottom: 10px; color: #a00; }
    #score { font-weight: bold; margin-bottom: 5px; }
    #timeRemaining { font-weight: bold; margin-bottom: 10px; }
    #timerBar {
      width: 800px;
      height: 15px;
      background: #ddd;
      margin-bottom: 10px;
      position: relative;
    }
    #timerFill {
      height: 100%;
      width: 100%;
      background: #ff4d4d;
      transition: width 0.1s linear;
    }
    #log { white-space: pre-wrap; font-size: 12px; max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
    #survey { display: none; margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px; }
    #exportBtn { margin-top: 10px; }
  </style>
</head>
<body>

<h2>Mouse Emotion Data Collection Game - Stress Mode</h2>

<p id="status">スタートボタンを押してストレスセッションを開始してください。</p>
<p id="score">スコア: 0</p>
<p id="timeRemaining">残り時間: 30.0 秒</p>
<div id="timerBar"><div id="timerFill"></div></div>
<button id="startBtn">ゲーム開始</button>

<div id="gameArea"></div>

<div id="survey">
  <h3>自己申告</h3>
  <label>Valence（1=とても不快, 7=とても快）:
    <input type="number" id="valenceInput" min="1" max="7" />
  </label><br><br>
  <label>Attentiveness（1=全く集中していない, 7=非常に集中）:
    <input type="number" id="attentivenessInput" min="1" max="7" />
  </label><br><br>
  <label>Confusion（1=全く困惑していない, 7=非常に困惑）:
    <input type="number" id="confusionInput" min="1" max="7" />
  </label><br><br>
  <button id="submitSurveyBtn">送信</button>
</div>

<button id="exportBtn">CSVエクスポート</button>
<pre id="log"></pre>

<script>
// =======================
// 設定
// =======================
const SESSION_TYPE = "STRESS";
const GAME_DURATION_MS = 30000;
const TARGET_RADIUS = 20;
const WINDOW_LENGTH_MS = 5000;
const SAMPLING_INTERVAL = 10;
const FAKE_TARGET_PROBABILITY = 0.4;
const MISS_PENALTY = 2; // フェイクターゲットの減点量
const DUMMY_MOVE_INTERVAL = 900; // ダミーの移動頻度(ms)

// =======================
// 状態変数
// =======================
let mouseLogs = [];
let lastSampleTime = 0;
let lastWindowEnd = performance.now();
let currentSessionId = null;
let windowFeatureBuffer = [];

const EMA_ALPHA = 0.05;
let personalBaseline = { mean: null, sampleCount: 0 };
let globalStats = { globalMean: null, globalStd: null, sampleCount: 0 };

// =======================
// マウスログ収集
// =======================
function logMouseEvent(e, type) {
  const now = performance.now();
  if (type === 'move' && now - lastSampleTime < SAMPLING_INTERVAL) return;
  lastSampleTime = now;
  mouseLogs.push({ mouse_x: e.clientX, mouse_y: e.clientY, timestamp: now, event_type: type });
}
document.addEventListener('mousemove', e => logMouseEvent(e, 'move'));
document.addEventListener('mousedown', e => logMouseEvent(e, 'click'));
document.addEventListener('mouseup',   e => logMouseEvent(e, 'release'));

// =======================
// 特徴量抽出（同一）
// =======================
function extractFeatures(logs) {
  if (!logs || logs.length < 2) return null;
  let trajectoryLength = 0;
  let deviations = [];
  let velocities = [];
  let pauses = 0;
  let directionChanges = 0;
  let curvatures = [];

  for (let i = 1; i < logs.length; i++) {
    const p0 = logs[i - 1];
    const p1 = logs[i];
    const dx = p1.mouse_x - p0.mouse_x;
    const dy = p1.mouse_y - p0.mouse_y;
    const dt = (p1.timestamp - p0.timestamp) / 1000;
    const dist = Math.hypot(dx, dy);
    trajectoryLength += dist;
    if (dt > 0) velocities.push(dist / dt);
    if (dt > 0.3) pauses++;
    deviations.push(dist);
    if (i >= 2) {
      const p_1 = logs[i - 2];
      const v1x = p0.mouse_x - p_1.mouse_x;
      const v1y = p0.mouse_y - p_1.mouse_y;
      const v2x = p1.mouse_x - p0.mouse_x;
      const v2y = p1.mouse_y - p0.mouse_y;
      const dot = v1x * v2x + v1y * v2y;
      const mag1 = Math.hypot(v1x, v1y);
      const mag2 = Math.hypot(v2x, v2y);
      if (mag1 > 0 && mag2 > 0) {
        const angle = Math.acos(Math.min(Math.max(dot / (mag1 * mag2), -1), 1));
        if (angle > Math.PI / 4) directionChanges++;
        curvatures.push(angle);
      }
    }
  }

  const meanDeviation = deviations.reduce((a, b) => a + b, 0) / deviations.length;
  const maxDeviation = Math.max(...deviations);
  const meanVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;
  const maxVelocity = Math.max(...velocities);
  const velocityStd = Math.sqrt(
    velocities.reduce((sum, v) => sum + Math.pow(v - meanVelocity, 2), 0) / velocities.length
  );
  const pauseRatio = pauses / logs.length;
  const curvatureMean = curvatures.length ? curvatures.reduce((a, b) => a + b, 0) / curvatures.length : 0;
  const curvatureStd = curvatures.length
    ? Math.sqrt(curvatures.reduce((s, c) => s + Math.pow(c - curvatureMean, 2), 0) / curvatures.length)
    : 0;

  return {
    trajectory_length: trajectoryLength,
    mean_deviation: meanDeviation,
    max_deviation: maxDeviation,
    direction_change_count: directionChanges,
    curvature_mean: curvatureMean,
    curvature_std: curvatureStd,
    mean_velocity: meanVelocity,
    max_velocity: maxVelocity,
    velocity_std: velocityStd,
    pause_ratio: pauseRatio
  };
}

// =======================
// ベースライン・正規化・推論（同一）
// =======================
function updateBaselineAndComputeDelta(features) {
  if (!features) return null;
  if (!personalBaseline.mean) {
    personalBaseline.mean = { ...features };
    personalBaseline.sampleCount = 1;
  } else {
    for (const key in features) {
      personalBaseline.mean[key] = EMA_ALPHA * features[key] + (1 - EMA_ALPHA) * personalBaseline.mean[key];
    }
    personalBaseline.sampleCount++;
  }
  const delta = {};
  for (const key in features) delta[key] = features[key] - personalBaseline.mean[key];
  return delta;
}

function updateGlobalStats(features) {
  if (!features) return;
  if (!globalStats.globalMean) {
    globalStats.globalMean = { ...features };
    globalStats.globalStd = {};
    for (const key in features) globalStats.globalStd[key] = 0;
    globalStats.sampleCount = 1;
  } else {
    globalStats.sampleCount++;
    for (const key in features) {
      const prevMean = globalStats.globalMean[key];
      const curr = features[key];
      const newMean = prevMean + (curr - prevMean) / globalStats.sampleCount;
      const prevVar = globalStats.globalStd[key] ** 2;
      const newVar = prevVar + (curr - prevMean) * (curr - newMean);
      globalStats.globalMean[key] = newMean;
      globalStats.globalStd[key] = Math.sqrt(newVar);
    }
  }
}

function buildModelInput(features, delta) {
  const input = [];
  for (const key in features) {
    const mean = globalStats.globalMean?.[key] ?? 0;
    const std = globalStats.globalStd?.[key] ?? 1;
    const z = std > 0 ? (features[key] - mean) / std : 0;
    input.push(z);
  }
  for (const key in delta) input.push(delta[key]);
  return input;
}

function dummyModelPredict(input) {
  const positive = Math.min(1, Math.max(0, 0.2 + input[0] * 0.1));
  const attentive = Math.min(1, Math.max(0, 0.85 + input[1] * 0.1));
  const confusion = Math.min(1, Math.max(0, 0.7 + input[2] * 0.1));
  return [positive, attentive, confusion];
}

function runInference(modelInput) {
  const output = dummyModelPredict(modelInput);
  return {
    positive_affect_score: output[0],
    attentiveness_score: output[1],
    confusion_score: output[2],
    confidence: 1.0,
    timestamp: Date.now()
  };
}

// =======================
// ウィンドウ処理ループ
// =======================
setInterval(() => {
  const now = performance.now();
  if (now - lastWindowEnd >= WINDOW_LENGTH_MS) {
    const windowLogs = mouseLogs.filter(log => log.timestamp >= lastWindowEnd && log.timestamp < now);
    lastWindowEnd = now;

    const features = extractFeatures(windowLogs);
    if (!features) return;

    updateGlobalStats(features);
    const delta = updateBaselineAndComputeDelta(features);
    const modelInput = buildModelInput(features, delta);
    const prediction = runInference(modelInput);

    windowFeatureBuffer.push({
      timestamp: Date.now(),
      session_id: currentSessionId,
      session_type: SESSION_TYPE,
      features,
      delta,
      modelInput,
      prediction
    });

    document.getElementById('log').textContent +=
      `\n[Window] ${JSON.stringify(prediction)}`;
  }
}, 500);

// =======================
// ゲームロジック（Stress・減点式）
// =======================
const gameArea = document.getElementById('gameArea');
const statusText = document.getElementById('status');
const scoreText = document.getElementById('score');
const timerFill = document.getElementById('timerFill');
const timeRemainingText = document.getElementById('timeRemaining');
let gameTimer = null;
let countdownTimer = null;
let dummyMoveTimer = null;
let target = null;
let fakeTarget = null;
let score = 0;
let startTime = null;
let gameActive = false;

function randomPosition() {
  const x = Math.random() * (gameArea.clientWidth - 2 * TARGET_RADIUS);
  const y = Math.random() * (gameArea.clientHeight - 2 * TARGET_RADIUS);
  return { x, y };
}

function createTarget() {
  if (target) target.remove();
  target = document.createElement('div');
  target.className = 'target';
  moveElementRandomly(target);
  target.addEventListener('click', () => {
    if (!gameActive) return;
    score++; // 正解は加点
    scoreText.textContent = `スコア: ${score}`;
    createTarget();
    maybeCreateFakeTarget();
  });
  gameArea.appendChild(target);
}

function createFakeTarget() {
  if (fakeTarget) fakeTarget.remove();
  fakeTarget = document.createElement('div');
  fakeTarget.className = 'fake-target';
  moveElementRandomly(fakeTarget);
  fakeTarget.addEventListener('click', () => {
    if (!gameActive) return;
    score = Math.max(0, score - MISS_PENALTY); // ❗ 減点式
    scoreText.textContent = `スコア: ${score}`;
    fakeTarget.remove();
    fakeTarget = null;
  });
  gameArea.appendChild(fakeTarget);
}

function maybeCreateFakeTarget() {
  if (Math.random() < FAKE_TARGET_PROBABILITY) {
    createFakeTarget();
  }
}

function moveElementRandomly(el) {
  const { x, y } = randomPosition();
  el.style.left = x + 'px';
  el.style.top = y + 'px';
}

function startGame() {
  score = 0;
  scoreText.textContent = "スコア: 0";
  mouseLogs = [];
  windowFeatureBuffer = [];
  currentSessionId = `session_${Date.now()}`;
  lastWindowEnd = performance.now();
  startTime = performance.now();
  gameActive = true;
  statusText.textContent = '【ストレスセッション】時間内にできるだけ多くクリックしてください。ミスすると減点されます。';
  document.getElementById('survey').style.display = 'none';

  createTarget();
  maybeCreateFakeTarget();

  gameTimer = setTimeout(endGame, GAME_DURATION_MS);

  countdownTimer = setInterval(() => {
    const elapsed = performance.now() - startTime;
    const remaining = Math.max(0, GAME_DURATION_MS - elapsed);
    const ratio = remaining / GAME_DURATION_MS;
    timerFill.style.width = `${ratio * 100}%`;
    timeRemainingText.textContent = `残り時間: ${(remaining / 1000).toFixed(1)} 秒`;
  }, 100);

  dummyMoveTimer = setInterval(() => {
    if (!gameActive) return;
    if (target) moveElementRandomly(target);
    if (fakeTarget) moveElementRandomly(fakeTarget);
  }, DUMMY_MOVE_INTERVAL);
}

function endGame() {
  gameActive = false;
  clearTimeout(gameTimer);
  clearInterval(countdownTimer);
  clearInterval(dummyMoveTimer);
  if (target) target.remove();
  if (fakeTarget) fakeTarget.remove();
  statusText.textContent = `セッション終了！スコア: ${score}`;
  document.getElementById('survey').style.display = 'block';
}

// =======================
// 自己申告処理
// =======================
document.getElementById('submitSurveyBtn').addEventListener('click', () => {
  const valence = Number(document.getElementById('valenceInput').value);
  const attentiveness = Number(document.getElementById('attentivenessInput').value);
  const confusion = Number(document.getElementById('confusionInput').value);
  if (!valence || !attentiveness || !confusion) {
    alert('すべての項目を入力してください。');
    return;
  }

  const record = {
    subject_id: 'S01',
    session_id: currentSessionId,
    session_type: SESSION_TYPE,
    label_valence: valence,
    label_attentiveness: attentiveness,
    label_confusion: confusion,
    windows: windowFeatureBuffer
  };

  const allData = JSON.parse(localStorage.getItem('emotionData') || '[]');
  allData.push(record);
  localStorage.setItem('emotionData', JSON.stringify(allData));

  document.getElementById('log').textContent += '\n[Saved] ' + JSON.stringify(record, null, 2);
  alert('データを保存しました！');
});

// =======================
// CSVエクスポート
// =======================
document.getElementById('exportBtn').addEventListener('click', () => {
  const allData = JSON.parse(localStorage.getItem('emotionData') || '[]');
  if (allData.length === 0) {
    alert('保存されたデータがありません。');
    return;
  }

  let csv = 'subject_id,session_id,session_type,window_timestamp,label_valence,label_attentiveness,label_confusion,feature_key,feature_value,delta_value\n';

  allData.forEach(session => {
    session.windows.forEach(win => {
      for (const key in win.features) {
        csv += `${session.subject_id},${session.session_id},${session.session_type},${win.timestamp},${session.label_valence},${session.label_attentiveness},${session.label_confusion},${key},${win.features[key]},${win.delta[key]}\n`;
      }
    });
  });

  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'emotion_dataset_stress.csv';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
});

// =======================
// イベントバインド
// =======================
document.getElementById('startBtn').addEventListener('click', startGame);
</script>

</body>
</html>