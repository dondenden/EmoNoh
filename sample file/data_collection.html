<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Mouse Emotion Inference System</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #log { white-space: pre-wrap; font-size: 12px; }
  </style>
</head>
<body>

<h2>Mouse Emotion Inference System</h2>
<p>マウスを動かしてください。5秒ごとに推論されます。</p>
<button id="exportBtn">ログをコンソール出力</button>
<pre id="log"></pre>

<script>
// =======================
// ① マウス生データ収集
// =======================

let mouseLogs = [];
const SAMPLING_INTERVAL = 10; // 約100Hz

let lastSampleTime = 0;

function logMouseEvent(e, type) {
  const now = performance.now();
  if (type === 'move' && now - lastSampleTime < SAMPLING_INTERVAL) return;
  lastSampleTime = now;

  mouseLogs.push({
    mouse_x: e.clientX,
    mouse_y: e.clientY,
    timestamp: now,
    event_type: type
  });
}

document.addEventListener('mousemove', e => logMouseEvent(e, 'move'));
document.addEventListener('mousedown', e => logMouseEvent(e, 'click'));
document.addEventListener('mouseup',   e => logMouseEvent(e, 'release'));

// =======================
// ② セグメンテーション
// =======================

const WINDOW_LENGTH_MS = 5000;
let lastWindowEnd = performance.now();

// =======================
// ④ 個人ベースライン
// =======================

const EMA_ALPHA = 0.05;
let personalBaseline = {
  mean: null,
  sampleCount: 0,
  lastUpdated: null
};

// =======================
// ⑥ 全体統計
// =======================

let globalStats = {
  globalMean: null,
  globalStd: null,
  sampleCount: 0
};

// =======================
// ③ 特徴量抽出
// =======================

function extractFeatures(logs) {
  if (!logs || logs.length < 2) return null;

  let trajectoryLength = 0;
  let maxDeviation = 0;
  let deviations = [];
  let velocities = [];
  let pauses = 0;
  let directionChanges = 0;
  let curvatures = [];

  for (let i = 1; i < logs.length; i++) {
    const p0 = logs[i - 1];
    const p1 = logs[i];

    const dx = p1.mouse_x - p0.mouse_x;
    const dy = p1.mouse_y - p0.mouse_y;
    const dt = (p1.timestamp - p0.timestamp) / 1000;

    const dist = Math.hypot(dx, dy);
    trajectoryLength += dist;

    if (dt > 0) velocities.push(dist / dt);
    if (dt > 0.3) pauses += 1;

    deviations.push(dist);

    if (i >= 2) {
      const p_1 = logs[i - 2];
      const v1x = p0.mouse_x - p_1.mouse_x;
      const v1y = p0.mouse_y - p_1.mouse_y;
      const v2x = p1.mouse_x - p0.mouse_x;
      const v2y = p1.mouse_y - p0.mouse_y;

      const dot = v1x * v2x + v1y * v2y;
      const mag1 = Math.hypot(v1x, v1y);
      const mag2 = Math.hypot(v2x, v2y);
      if (mag1 > 0 && mag2 > 0) {
        const angle = Math.acos(Math.min(Math.max(dot / (mag1 * mag2), -1), 1));
        if (angle > Math.PI / 4) directionChanges += 1;
        curvatures.push(angle);
      }
    }
  }

  const meanDeviation = deviations.reduce((a, b) => a + b, 0) / deviations.length;
  maxDeviation = Math.max(...deviations);
  const meanVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;
  const maxVelocity = Math.max(...velocities);
  const velocityStd = Math.sqrt(
    velocities.reduce((sum, v) => sum + Math.pow(v - meanVelocity, 2), 0) / velocities.length
  );
  const pauseRatio = pauses / logs.length;
  const curvatureMean = curvatures.length ? curvatures.reduce((a, b) => a + b, 0) / curvatures.length : 0;
  const curvatureStd = curvatures.length
    ? Math.sqrt(curvatures.reduce((s, c) => s + Math.pow(c - curvatureMean, 2), 0) / curvatures.length)
    : 0;

  return {
    trajectory_length: trajectoryLength,
    mean_deviation: meanDeviation,
    max_deviation: maxDeviation,
    direction_change_count: directionChanges,
    curvature_mean: curvatureMean,
    curvature_std: curvatureStd,
    mean_velocity: meanVelocity,
    max_velocity: maxVelocity,
    velocity_std: velocityStd,
    pause_ratio: pauseRatio
  };
}

// =======================
// ④ 個人ベースライン更新 + ⑤ 差分
// =======================

function updateBaselineAndComputeDelta(features) {
  if (!features) return null;

  if (!personalBaseline.mean) {
    personalBaseline.mean = { ...features };
    personalBaseline.sampleCount = 1;
    personalBaseline.lastUpdated = Date.now();
  } else {
    for (const key in features) {
      const prev = personalBaseline.mean[key];
      const curr = features[key];
      personalBaseline.mean[key] = EMA_ALPHA * curr + (1 - EMA_ALPHA) * prev;
    }
    personalBaseline.sampleCount += 1;
    personalBaseline.lastUpdated = Date.now();
  }

  const delta = {};
  for (const key in features) {
    delta[key] = features[key] - personalBaseline.mean[key];
  }

  return delta;
}

// =======================
// ⑥ 全体統計更新
// =======================

function updateGlobalStats(features) {
  if (!features) return;

  if (!globalStats.globalMean) {
    globalStats.globalMean = { ...features };
    globalStats.globalStd = {};
    for (const key in features) {
      globalStats.globalStd[key] = 0;
    }
    globalStats.sampleCount = 1;
  } else {
    globalStats.sampleCount += 1;
    for (const key in features) {
      const prevMean = globalStats.globalMean[key];
      const curr = features[key];

      const newMean = prevMean + (curr - prevMean) / globalStats.sampleCount;

      const prevVar = globalStats.globalStd[key] ** 2;
      const newVar = prevVar + (curr - prevMean) * (curr - newMean);

      globalStats.globalMean[key] = newMean;
      globalStats.globalStd[key] = Math.sqrt(newVar);
    }
  }
}

// =======================
// ⑦ モデル入力構築
// =======================

function buildModelInput(features, delta) {
  const input = [];

  for (const key in features) {
    const mean = globalStats.globalMean?.[key] ?? 0;
    const std = globalStats.globalStd?.[key] ?? 1;
    const z = std > 0 ? (features[key] - mean) / std : 0;
    input.push(z);
  }

  for (const key in delta) {
    input.push(delta[key]);
  }

  return input;
}

// =======================
// ⑧ 推論（ダミーモデル）
// =======================

function computeConfidence(outputs) {
  const eps = 1e-8;
  const entropy = -outputs.reduce((sum, p) => sum + p * Math.log(p + eps), 0);
  const maxEntropy = Math.log(outputs.length);
  return 1 - entropy / maxEntropy;
}

// ダミーモデル（後で差し替え）
function dummyModelPredict(input) {
  const positive = Math.min(1, Math.max(0, 0.5 + input[0] * 0.1));
  const attentive = Math.min(1, Math.max(0, 0.5 + input[1] * 0.1));
  return [positive, attentive];
}

function runInference(modelInput) {
  const output = dummyModelPredict(modelInput);
  const positive_affect_score = output[0];
  const attentiveness_score = output[1];
  const confidence = computeConfidence(output);

  return {
    positive_affect_score,
    attentiveness_score,
    confidence,
    timestamp: Date.now()
  };
}

// =======================
// ② ウィンドウ処理ループ
// =======================

setInterval(() => {
  const now = performance.now();
  if (now - lastWindowEnd >= WINDOW_LENGTH_MS) {
    const windowLogs = mouseLogs.filter(log => log.timestamp >= lastWindowEnd && log.timestamp < now);
    lastWindowEnd = now;

    const features = extractFeatures(windowLogs);
    if (!features) return;

    updateGlobalStats(features);
    const delta = updateBaselineAndComputeDelta(features);
    const modelInput = buildModelInput(features, delta);
    const prediction = runInference(modelInput);

    const outputText = `
--- Window Result ---
Features: ${JSON.stringify(features, null, 2)}
Delta: ${JSON.stringify(delta, null, 2)}
Model Input: ${JSON.stringify(modelInput, null, 2)}
Prediction: ${JSON.stringify(prediction, null, 2)}
`;
    document.getElementById('log').textContent += outputText;
    console.log(outputText);
  }
}, 500);

// =======================
// ログ出力ボタン
// =======================

document.getElementById('exportBtn').addEventListener('click', () => {
  console.log("Collected raw logs:", mouseLogs);
});
</script>

</body>
</html>