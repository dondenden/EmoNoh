<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>EmoNoh Keystroke Emotion Estimation - è‡ªå‹•ãƒ©ãƒ™ãƒ«ç‰ˆ</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js"></script>
  <style>
    body { font-family: sans-serif; background:#f3f6fb; padding:20px; }
    #gameArea {
      background:white; padding:20px; max-width:500px;
      border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.1);
    }
    #target { font-size: 28px; font-weight: bold; margin-bottom: 10px; }
    #inputBox { font-size: 24px; width: 100%; padding: 5px; }
    button { margin-top: 8px; margin-right: 5px; padding: 8px 14px; }
    #status { margin-top: 15px; font-weight: bold; }
    #phaseLabel { font-weight:bold; color:#555; }
  </style>
</head>
<body>
  <h1>ğŸ® EmoNoh â€” è‡ªå‹•ãƒ©ãƒ™ãƒªãƒ³ã‚°ä»˜ã Keystroke æ„Ÿæƒ…æ¨å®š</h1>

  <div id="gameArea">
    <div>ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚º: <span id="phaseLabel">æœªé–‹å§‹</span></div>
    <div id="target">--- START ---</div>
    <input type="text" id="inputBox" disabled>
    <br>
    <button id="startGame">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button id="train">ãƒ¢ãƒ‡ãƒ«å­¦ç¿’</button>
    <button id="predict">æ¨å®š</button>
    <div id="status">çŠ¶æ…‹: å¾…æ©Ÿä¸­</div>
  </div>

  <script>
    const classNames = ["é›†ä¸­", "å›°æƒ‘", "é€€å±ˆ"];
    const phaseLabel = document.getElementById('phaseLabel');
    const target = document.getElementById('target');
    const input = document.getElementById('inputBox');
    const status = document.getElementById('status');

    let currentPhase = 0; // 0=é›†ä¸­,1=å›°æƒ‘,2=é€€å±ˆ
    let trialCount = 0;
    const totalTrialsPerPhase = 5;

    let model;
    const examples = [];
    const labels = [];

    let keystrokeIntervals = [];
    let lastKeyTime = null;
    let errorCount = 0;
    let startTime;
    let word;
    let finished = false;
    let timeLimit = null;
    let timerId = null;

    function randomWord(length){
      const chars = 'abcdefghijklmnopqrstuvwxyz';
      return Array.from({length},()=>chars[Math.floor(Math.random()*chars.length)]).join('');
    }

    // é›£æ˜“åº¦è¨­å®š
    function getWordForPhase(phase){
      if (phase === 0) return randomWord(5);    // Easy
      if (phase === 1) return randomWord(10);   // Hard
      if (phase === 2) return randomWord(3);    // Boring
    }

    function getTimeLimitForPhase(phase){
      if (phase === 0) return null;   // ç„¡åˆ¶é™
      if (phase === 1) return 5000;   // 5ç§’
      if (phase === 2) return null;   // ç„¡åˆ¶é™
    }

    // ã‚²ãƒ¼ãƒ 1å›åˆ†é–‹å§‹
    function startTrial(){
      const wordLength = getWordForPhase(currentPhase);
      word = getWordForPhase(currentPhase);
      timeLimit = getTimeLimitForPhase(currentPhase);
      target.textContent = word;
      input.value = '';
      input.disabled = false;
      input.focus();
      keystrokeIntervals = [];
      lastKeyTime = null;
      errorCount = 0;
      finished = false;
      startTime = Date.now();
      status.textContent = `çŠ¶æ…‹: ãƒ—ãƒ¬ã‚¤ä¸­ (${classNames[currentPhase]})`;

      if (timeLimit) {
        timerId = setTimeout(()=>{
          if (!finished) {
            input.disabled = true;
            finished = true;
            recordData();
            nextTrial();
          }
        }, timeLimit);
      }
    }

    // ã‚­ãƒ¼æŠ¼ä¸‹é–“éš”
    input.addEventListener('keydown', e=>{
      if (finished) return;
      const now = Date.now();
      if (lastKeyTime) keystrokeIntervals.push(now - lastKeyTime);
      lastKeyTime = now;
    });

    // å…¥åŠ›ä¸­ã«ãƒŸã‚¹æ¤œå‡º
    input.addEventListener('input', ()=>{
      const val = input.value;
      if (!word.startsWith(val)) errorCount++;
      if (val === word) {
        finished = true;
        input.disabled = true;
        if (timerId) clearTimeout(timerId);
        recordData();
        nextTrial();
      }
    });

    // ç‰¹å¾´é‡æŠ½å‡º
    function getFeatures(){
      const avgInterval = keystrokeIntervals.length
        ? keystrokeIntervals.reduce((a,b)=>a+b,0)/keystrokeIntervals.length
        : 0;
      const speed = word.length / ((Date.now()-startTime)/1000);
      return [avgInterval || 0, errorCount, speed];
    }

    // ãƒ‡ãƒ¼ã‚¿è¨˜éŒ²
    function recordData(){
      const feat = getFeatures();
      examples.push(feat);
      labels.push(currentPhase);
      status.textContent = `ğŸ“Š ãƒ‡ãƒ¼ã‚¿æ•°: ${examples.length}`;
    }

    // æ¬¡ã®ãƒˆãƒ©ã‚¤ã‚¢ãƒ«ã¸
    function nextTrial(){
      trialCount++;
      if (trialCount >= totalTrialsPerPhase) {
        currentPhase++;
        trialCount = 0;
        if (currentPhase > 2) {
          status.textContent = "âœ… ã™ã¹ã¦ã®ãƒ•ã‚§ãƒ¼ã‚ºãŒå®Œäº†ã—ã¾ã—ãŸï¼";
          input.disabled = true;
          return;
        }
      }
      phaseLabel.textContent = classNames[currentPhase];
      setTimeout(startTrial, 1000);
    }

    // ã‚²ãƒ¼ãƒ å…¨ä½“é–‹å§‹
    document.getElementById('startGame').addEventListener('click', ()=>{
      currentPhase = 0;
      trialCount = 0;
      phaseLabel.textContent = classNames[currentPhase];
      startTrial();
    });

    // ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰
    function createModel(){
      const m = tf.sequential();
      m.add(tf.layers.dense({inputShape:[3], units:16, activation:'relu'}));
      m.add(tf.layers.dense({units:8, activation:'relu'}));
      m.add(tf.layers.dense({units:3, activation:'softmax'}));
      m.compile({optimizer: tf.train.adam(0.01), loss:'categoricalCrossentropy', metrics:['accuracy']});
      return m;
    }

    // å­¦ç¿’
    document.getElementById('train').addEventListener('click', async ()=>{
      if (examples.length < 10) return alert("ãƒ‡ãƒ¼ã‚¿ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã‚²ãƒ¼ãƒ ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚");
      const xs = tf.tensor2d(examples);
      const ys = tf.oneHot(tf.tensor1d(labels,'int32'), 3);
      model = createModel();
      await model.fit(xs, ys, {epochs: 50, shuffle:true});
      xs.dispose(); ys.dispose();
      status.textContent = "ğŸ§  ãƒ¢ãƒ‡ãƒ«å­¦ç¿’å®Œäº†";
    });

    // æ¨å®š
    document.getElementById('predict').addEventListener('click', async ()=>{
      if (!model) return alert("ãƒ¢ãƒ‡ãƒ«ã‚’å…ˆã«å­¦ç¿’ã—ã¦ãã ã•ã„");
      const feat = getFeatures();
      const t = tf.tensor2d([feat]);
      const pred = model.predict(t);
      const arr = await pred.data();
      const idx = arr.indexOf(Math.max(...arr));
      status.textContent = `ğŸª æ¨å®šæ„Ÿæƒ…: ${classNames[idx]} (ç¢ºä¿¡åº¦ ${(arr[idx]*100).toFixed(1)}%)`;
      t.dispose(); pred.dispose();
    });
  </script>
</body>
</html>